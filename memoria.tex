%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la EIF - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela de Ingeniería de Fuenlabrada
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}

%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
% Escribe el título y el nombre del autor / autora para que se use bien
% en otras partes de la plantilla
% Dependiendo de las partes de la plantilla, a veces aparecerán tal
% cual los escribas, a veces totalmente en mayúsculas, a veces de otras
% formas
% TODO - Elegir un buen título
\title{Chomp Crawler: Adaptación al Entorno Web del Pac-Man Clásico.}
\author{Diego Sota Rebollo}

% Guarda el título, el autor y la fecha en variables
\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
	\begin{center}
		\includegraphics[scale=0.6]{img/URJ_logo_Color_POS.png}

		\vspace{1.75cm}

		\LARGE
		ESCUELA DE INGENIERÍA DE FUENLABRADA
		\vspace{1cm}

		\LARGE
		GRADO EN INGENIERÍA EN SISTEMAS AUDIOVISUALES Y MULTIMEDIA

		\vspace{1cm}
		\LARGE
		\textbf{TRABAJO FIN DE GRADO}

		\vspace{2cm}

		\Large
		\MakeUppercase{\thetitle}

		\vspace{2cm}

		\large
		Autor: \theauthor \\
		%-- JGB - Revisar, ¿te gusta así?
		Tutor: Dr. Jesús María González Barahona\\
		\vspace{1cm}

		\large
		Curso académico 2025/2026

	\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Licencia
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{12cm}

%% Licencia de publicación en abierto elegida
%% Ver detalles en https://ofilibre.urjc.es/guias/tfg-abierto/

\begin{flushright}
	\includegraphics[scale=0.6]{img/by-sa}
	%\includegraphics[scale=0.6]{img/by}

	%% TODO - Poner el año adecuado
	\noindent©2025 \theauthor  \\
	Algunos derechos reservados  \\
	Este documento se distribuye bajo la licencia \\
	``Atribución-CompartirIgual 4.0 Internacional'' de Creative Commons, \\
	disponible en \\
	\url{https://creativecommons.org/licenses/by-sa/4.0/deed.es}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
	\textit{Dedicado a
		Amparo Rebollo, \\
		por enseñarme el valor de la memoria.}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

% TODO - Escribir agradecimientos
\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 
%! Aquí vienen los agradecimientos. Aunque está bien acordarse de la pareja, 
%! no hay que olvidarse de dar las gracias a tu madre, que aunque a veces no lo parezca 
%! disfrutará tanto de tus logros como tú 
%! Además, la pareja quizás no sea para siempre, pero tu madre sí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen
% TODO - Escribir resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado
%!Aquí viene un resumen del proyecto.
%!Ha de constar de tres o cuatro párrafos, donde se presente de manera clara y concisa de qué va el proyecto. 
%!Han de quedar respondidas las siguientes preguntas:
%!¿De qué va este proyecto? ¿Cuál es su objetivo principal?
%!¿Cómo se ha realizado? ¿Qué tecnologías están involucradas?
%!¿En qué contexto se ha realizado el proyecto? ¿Es un proyecto dentro de un marco general?
%!Lo mejor es escribir el resumen al final.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés
% TODO - Write summary 

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

%! Here comes a translation of the ``Resumen'' into English. 
%! Please, double check it for correct grammar and spelling.
%! As it is the translation of the ``Resumen'', which is supposed 
%! to be written at the end, this as well should be filled out just before submitting.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.
% TODO Gestionar índices

%%%% Índice de contenidos
\tableofcontents
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

%! En este capítulo se introduce el proyecto.
%! Debería tener información general sobre el mismo, 
%! dando la información sobre el contexto en el que se ha desarrollado.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)

\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo-general} % identificador de sección (no se muestra, es para poder referenciarla)

Este trabajo tiene como objetivo crear un videojuego completo y funcional,
inspirado en el clásico juego de arcade Pacman, con mecánicas originales del género Rogue-like,
tilizando tecnologías web.


\section{Objetivos específicos}
\label{sec:objetivos-especificos}

Mediante la realización de este trabajo, se busca alcanzar los siguientes objetivos:

Exploración de tecnologías web relacionadas con gráficos 3D y desarrollo de interfaces de usuario,
a fin de comprender sus capacidades y limitaciones en el contexto del desarrollo de videojuegos.

Desarrollar un proyecto completo que abarque desde la concepción inicial hasta la implementación final,
incluyendo diseño, programación, pruebas y documentación.

Revisitar y poner en práctica algunos de los conceptos centrales del grado de Ingeniería en
Sistemas Audiovisuales y Multimedia, aplicándolos en un proyecto que sintetice los
conocimientos adquiridos durante el mismo.

Se ha buscado la obtención de una experiencia de juego con la rejugabilidad como máxima,
mediante la re-implementación de un algoritmo de generación procedural de laberintos,
representados en forma de \emph{Tilemaps}.
Para conseguir una experiencia accesible desde una amplia gama de dispositivos,
se ha seleccionado la tecnología web, mediante la representación de gráficos en tres dimensiones.
% TODO - Explicar mejor y decidir como citar

A nivel de estructura, se ha optado por diseñar un sistema propio,
basado en \emph{ECS}, que permite separar correctamente las responsabilidades
dentro del flujo de ejecución de la lógica del juego.

\section{Planificación temporal}
\label{sec:planificacion-temporal}
%TODO - Planificación temporal

% A mí me gusta que aquí pongáis una descripción de lo que os ha llevado realizar el trabajo.
% Hay gente que añade un diagrama de GANTT.
% Lo importante es que quede claro cuánto tiempo llevas (tiempo natural, p.ej., 6 meses) y
% a qué nivel de esfuerzo (p.ej., principalmente los fines de semana).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}
\section{Análisis Técnico de Pac-Man}
\label{sec:analisis_pacman}

Para comprender la magnitud de la ingeniería detrás de \emph{Pac-Man}, es indispensable acudir a la documentación
técnica exhaustiva recopilada por Jamey Pittman en \emph{The Pac-Man Dossier} \cite{pittman_pacman_dossier}.
Este compendio, fruto de la ingeniería inversa y el análisis del desensamblado del código original en ROM,
revela que la aparente simplicidad del juego esconde un sistema determinista de alta complejidad.
A diferencia de las aproximaciones modernas basadas en heurísticas complejas, \emph{Pac-Man} demuestra cómo
un conjunto de reglas lógicas elementales, ejecutadas sobre hardware limitado, puede generar comportamientos
emergentes sofisticados.
A continuación, se desgranan los aspectos críticos de su diseño basándose en esta referencia técnica.

\subsection{Historia y relevancia en la industria}
Desarrollado por Namco y diseñado por Toru Iwatani, \emph{Pac-Man} (originalmente \emph{Puck-Man}) debutó en Japón
el 22 de mayo de 1980. En un mercado saturado por \emph{shooters} espaciales derivados del éxito de \emph{Space Invaders},
Iwatani buscó expandir la demografía de los salones recreativos hacia el público femenino y las parejas. Para ello,
conceptualizó una mecánica centrada en ``comer'' (\emph{taberu} en japonés), alejándose de la violencia explícita.
El diseño de personajes, inspirado en la cultura \emph{kawaii}, y el uso pionero de colores pastel sobre un fondo negro,
rompieron con la estética militarista predominante.

La llegada del título a Estados Unidos en octubre de 1980, licenciado por Midway, supuso un fenómeno cultural sin precedentes.
A nivel técnico, el juego introdujo innovaciones que definirían el medio: fue uno de los primeros en implementar
\emph{cutscenes} o interludios narrativos y, más importante aún, dotó a los enemigos de ``personalidad'' mediante algoritmos
de comportamiento diferenciados.
Esta decisión de diseño transformó a los fantasmas de meros obstáculos móviles a agentes con roles tácticos específicos,
sentando las bases de la inteligencia artificial en videojuegos.

\subsection{Mecánicas fundamentales y sistema de teselas}
La lógica de \emph{Pac-Man} opera sobre una cuadrícula de teselas (\emph{tilemap}) de $28 \times 36$ celdas, donde cada tesela
equivale a $8 \times 8$ píxeles. El movimiento de los actores (Pac-Man y los fantasmas) no es libre, sino que está restringido
a los centros de estas teselas. El motor del juego evalúa la posición de cada entidad basándose en su píxel central; si este punto
entra en una nueva tesela, se actualiza la lógica de ocupación.
Este sistema discretizado permite simplificar la detección de colisiones: la muerte del jugador ocurre únicamente cuando su tesela
ocupada coincide con la de un fantasma.

Una restricción mecánica crucial es la prohibición de detenerse o invertir el sentido de la marcha voluntariamente.
Los fantasmas siempre deben avanzar hacia la siguiente tesela disponible, evaluando las intersecciones antes de llegar a ellas.
Esta anticipación es clave: la decisión de giro se toma un paso antes de la intersección física, basándose en la distancia euclidiana
hacia una ``tesela objetivo'' (\emph{Target Tile}).
Este determinismo permite a los jugadores expertos predecir y manipular el flujo del juego, transformando la experiencia de reacción
en una de planificación estratégica.


\subsection{Inteligencia Artificial: El sistema de objetivos}
La ``personalidad'' de cada fantasma es el resultado de asignar una tesela objetivo (\emph{Target Tile}) diferente a cada uno,
calculada en tiempo real según la posición del jugador. Según el análisis de Pittman, los comportamientos se definen de la siguiente manera:

\begin{itemize}
	\item \textbf{Blinky (Rojo - \emph{Shadow}):} Su objetivo es la tesela que ocupa actualmente Pac-Man.
	      Esto genera una persecución directa e implacable, actuando como una sombra que sigue la ruta más corta hacia el jugador.
	\item \textbf{Pinky (Rosa - \emph{Speedy}):} Su lógica apunta a cuatro teselas por delante de la posición actual de Pac-Man.
	      Esto provoca que intente emboscar al jugador, cortándole el paso en las intersecciones en lugar de seguirlo desde atrás.
	\item \textbf{Inky (Cian - \emph{Bashful}):} Utiliza una lógica vectorial compleja. Se traza un vector desde la posición de Blinky
	      hasta dos teselas por delante de Pac-Man, y se duplica esa distancia en la dirección opuesta.
	      Esto hace que su movimiento dependa de la posición relativa de su compañero rojo, resultando en maniobras de flanqueo difíciles
	      de predecir.
	\item \textbf{Clyde (Naranja - \emph{Pokey}):} Posee un comportamiento dual basado en la proximidad.
	      Si está a más de ocho teselas de Pac-Man, su objetivo es el jugador (como Blinky). Sin embargo, si se acerca a menos de ocho
	      teselas, su objetivo cambia inmediatamente a su esquina de patrulla (esquina inferior izquierda), haciéndole huir y parecer
	      desinteresado o ``tonto''.
\end{itemize}

\subsection{Ciclos de comportamiento y dificultad}
El ritmo del juego está dictado por la alternancia cíclica entre dos modos globales de comportamiento:
\emph{Scatter} (Dispersión) y \emph{Chase} (Persecución).
Durante el modo \emph{Scatter}, cada fantasma ignora al jugador y trata de alcanzar una tesela objetivo fija en una de las cuatro esquinas
del laberinto, lo que les obliga a patrullar zonas específicas y da un respiro al jugador. Tras un tiempo predefinido, cambian a modo
\emph{Chase}, activando sus algoritmos de persecución individuales descritos anteriormente.
Estos ciclos se repiten en intervalos fijos (ej. 7 segundos de dispersión, 20 de persecución) que varían según el nivel.

La curva de dificultad no se basa solo en la velocidad, sino en la alteración de estos tiempos. A medida que se superan niveles,
los periodos de \emph{Scatter} se reducen drásticamente hasta desaparecer, manteniendo a los fantasmas en persecución constante.
Adicionalmente, se introduce la mecánica de ``Cruise Elroy'': cuando quedan pocos puntos en el mapa, Blinky aumenta su velocidad
porcentualmente, llegando a superar la del propio Pac-Man, lo que intensifica la tensión final de cada nivel.


\section{Técnicas utilizadas}
\subsection{Generación procedural de laberintos.}
Si bien la literatura académica estandariza algoritmos de árboles de expansión como
\textit{Prim} o \textit{Recursive Backtracking} para la creación de laberintos,
su aplicación resulta inviable para mecánicas tipo \textit{Pac-Man}. Estos métodos
generan matemáticamente ``laberintos perfectos'' ---estructuras acíclicas repletas de callejones
sin salida---, lo que anula las rutas de evasión y la dinámica de persecución cíclica esencial
en el género arcade. Debido a estas limitaciones estructurales, se ha descartado el uso de
generadores de grafos convencionales en favor de la implementación basada en restricciones
de teselas propuesta por Lebron \cite{shaunlebron:pacman-mazegen}. Esta solución específica permite imponer
condiciones de diseño no triviales, tales como la simetría axial del tablero, la eliminación de
\textit{dead-ends} (\textit{braiding}) y la reserva de zonas funcionales para la IA
(``casa de fantasmas''), garantizando niveles topológicamente válidos para la navegación
de agentes autónomos.

\subsection{Arquitectura Entity Component System (ECS)}
El desarrollo de videojuegos modernos ha evidenciado las limitaciones estructurales de la
Programación Orientada a Objetos (OOP) clásica, especialmente cuando se enfrentan problemas de
jerarquías de herencia rígidas y cuellos de botella en el rendimiento de la memoria. Se ha considerado
la arquitectura \emph{Entity Component System} (ECS), un patrón arquitectónico que prioriza la composición
sobre la herencia y separa estrictamente los datos del comportamiento.
A diferencia del modelo tradicional donde un objeto encapsula ambos aspectos, en ECS una \emph{Entidad} se reduce a un
identificador único (generalmente un entero) que carece de lógica o datos propios; su función es actuar como un contenedor
abstracto que agrupa \emph{Componentes} \cite{nystrom2014game}. Estos componentes son estructuras de datos puras (structs),
desprovistas de métodos, que almacenan el estado específico de un aspecto del juego (e.g., `Posición`, `Velocidad`, `Renderable`).

La lógica del juego se traslada a los \emph{Sistemas}, que operan de manera transversal sobre conjuntos de entidades que poseen una firma
de componentes específica. Por ejemplo, un \emph{Sistema de Movimiento} iterará sobre todas las entidades que posean tanto `Posición`
como `Velocidad`, actualizando los datos de la primera en función de la segunda, ignorando cualquier otro atributo.
Este desacoplamiento total permite una flexibilidad extrema en tiempo de diseño: es posible crear nuevos tipos de enemigos o
comportamientos emergentes simplemente combinando componentes existentes, sin necesidad de refactorizar complejas cadenas
de herencia ni enfrentarse al ``problema del diamante'' típico de la OOP \cite{harkonen2019advantages}.

\section{Tecnologías}

\subsection{HTML5 y los navegadores web modernos.}

HTML5 representa la evolución más significativa del estándar HyperText Markup Language (HTML),
establecido por el World Wide Web Consortium (W3C) como la base para el desarrollo de aplicaciones web
ricas y multimedia \cite{w3c_html5}. A diferencia de versiones anteriores centradas en la presentación de
contenido estático, HTML5 introduce APIs nativas que habilitan funcionalidades avanzadas, tales como la
reproducción de audio y vídeo sin plugins externos, el almacenamiento local de datos y la manipulación de gráficos
en dos y tres dimensiones mediante WebGL.
Esta expansión de capacidades ha transformado los navegadores web en plataformas completas para el desarrollo de
aplicaciones interactivas, eliminando la dependencia de tecnologías propietarias como Flash.

La selección de HTML5 se justifica por su accesibilidad multiplataforma y soporte nativo en navegadores modernos
como Chrome y Firefox, facilitando la ejecución sin instalación y la integración con WebGL para gráficos 3D.
Además, simplifica el despliegue y promueve la interoperabilidad, demostrando la viabilidad de los navegadores
para videojuegos complejos \cite{mdn_web_apis} \cite{freeman2011definitive}.

\subsection{EcmaScript 6 y Typescript.}

La base del desarrollo se fundamenta en JavaScript moderno, entendido como la implementación del estándar internacional
ECMA-262 (ECMAScript) \cite{ecma262}. Se toma como punto de inflexión la especificación ES6 (ES2015) y sus sucesoras,
que introdujeron la sintaxis de módulos, promesas y clases, permitiendo al lenguaje evolucionar desde simples scripts a
arquitecturas de software complejas \cite{rauschmayer2014exploring}.
Esta evolución resulta esencial para proyectos web de escala, ya que facilita la modularización del código y la gestión asíncrona,
alineándose con las necesidades de un videojuego interactivo que requiere actualizaciones en tiempo real y manejo eficiente de eventos.

Para garantizar la escalabilidad y la seguridad del código en un entorno de producción, se adopta TypeScript.
Esta tecnología opera como un superconjunto sintáctico estricto de JavaScript que añade tipado estático opcional y
comprobación de errores en tiempo de compilación \cite{cherny2019programming}. TypeScript no reemplaza a JavaScript,
sino que mejora la experiencia de desarrollo (DX) y la mantenibilidad, transpilándose finalmente a código JavaScript
estándar compatible con cualquier navegador o entorno Node.js, asegurando así un código autodocumentado y resiliente
ante errores de tipo comunes en tiempo de ejecución.
Esta elección se justifica por la complejidad inherente a un proyecto de videojuego, donde la detección temprana de errores
reduce significativamente el tiempo de depuración.

\subsection{Gráficos 3D en la web con WebGL.\@ \emph{Three.js.}}

WebGL (Web Graphics Library) surge como la estandarización llevada a cabo por el Khronos Group para trasladar las capacidades de
OpenGL ES 2.0 a los navegadores web, permitiendo renderizado de gráficos 3D acelerados por hardware directamente en el
elemento canvas de HTML5 sin necesidad de plugins \cite{khronos_webgl_spec}.
Esta API de bajo nivel proporciona acceso directo a la GPU mediante programas de sombreado (shaders) escritos en GLSL,
habilitando efectos visuales complejos y rendimiento óptimo en aplicaciones web \cite{mdn_webgl}.
Sin embargo, su complejidad técnica resulta excesivamente verbosa para el desarrollo ágil, requiriendo gestión manual de matrices,
buffers y estados gráficos.

Para mitigar esta complejidad, se integra Three.js, una biblioteca de alto nivel que abstrae las primitivas de WebGL mediante una
arquitectura orientada a objetos \cite{threejs_docs}\footnote{\url{https://github.com/mrdoob/three.js}}.
Three.js gestiona el grafo de escena, las cámaras, la iluminación y los materiales, permitiendo focalizar el desarrollo en la
lógica visual y la experiencia de usuario en lugar de en la gestión matemática de matrices y buffers de memoria crudos.
Esta abstracción resulta esencial para proyectos de videojuegos web, donde la productividad del desarrollador y la mantenibilidad del
código son críticas para cumplir con plazos y objetivos de calidad.

Se ha elegido esta tecnología por su adopción generalizada en la industria del desarrollo web. Además, resulta muy pertinente
en el contexto del Grado en Ingeniería en Sistemas Audiovisuales y Multimedia, siendo una tecnología en la que se ha profundizado
durante el plan de estudios.

\subsection{Interfaces Gráficas de Usuario con \emph{React.js}. Estados globales con \emph{Zustand}}

React.js, desarrollado originalmente por Facebook (ahora Meta) en 2013 para solucionar problemas de rendimiento en interfaces con
actualizaciones de datos masivas y constantes, se ha establecido como la biblioteca estándar de facto para la construcción de
interfaces de usuario modernas~\cite{react_docs}. Su filosofía se centra en una arquitectura basada en componentes reutilizables
y un paradigma declarativo, donde el desarrollador define ``qué'' debe mostrarse y la biblioteca gestiona el ``cómo'' \cite{banks2020learning}.
La clave de su eficiencia reside en el Virtual DOM, una representación en memoria del árbol de elementos que permite ejecutar un
algoritmo de reconciliación (Diffing Algorithm), actualizando en el DOM real únicamente aquellos nodos que han sufrido cambios.
Esto supone una optimización drástica en términos de rendimiento frente a la manipulación directa del navegador.

La selección de React se justifica por su madurez en el ecosistema de desarrollo web y su capacidad para gestionar interfaces complejas
con múltiples actualizaciones de estado, como es el caso de un videojuego donde la UI debe reflejar constantemente cambios en puntuaciones,
vidas y estados de juego. Además, resulta pertinente en el contexto del Grado en Ingeniería en Sistemas Audiovisuales y Multimedia,
siendo una tecnología que permite aplicar los conocimientos adquiridos en desarrollo de aplicaciones web de forma ágil. Siendo un
framework ampliamente adoptado en la industria, su uso en este proyecto facilita la adquisición de habilidades prácticas y relevantes
para el mercado laboral.

Complementando a React, se integra Zustand para la gestión del estado global de la aplicación. Esta librería ha experimentado una
adopción exponencial debido a su capacidad para simplificar el flujo de datos sin el \emph{boilerplate} o código repetitivo excesivo asociado
a soluciones tradicionales como \emph{Redux} \cite{zustand_docs}. Zustand utiliza un modelo de almacén (store) centralizado basado en hooks
que permite a cualquier componente acceder y modificar el estado de manera directa y reactiva, resolviendo problemas de paso de
propiedades por múltiples niveles de componentes (prop-drilling) con una huella de memoria mínima y una API extremadamente concisa.
Esta elección resulta crítica para la gestión del estado de un videojuego, donde posiciones de entidades, puntuaciones y eventos
requieren actualizaciones frecuentes sin comprometer el rendimiento.

\subsection{\emph{React Three Fiber}.\@ Integración de Three con React}

React Three Fiber (R3F) se implementa como un renderizador personalizado de React para Three.js, actuando como un puente arquitectónico
que traslada el paradigma declarativo y basado en componentes de React al entorno imperativo de los gráficos 3D \cite{r3f_docs}.
A diferencia de una simple envoltura (wrapper), R3F crea un grafo de escena dinámico donde cada objeto 3D se instancia como un
componente nativo de React, permitiendo gestionar el ciclo de vida, los eventos y el estado de la escena (cámaras, mallas, luces)
mediante el ecosistema estándar de hooks, props y contexto. Esta arquitectura es posible gracias a la API de renderizadores personalizados
de React, que permite extender el framework más allá del DOM tradicional \cite{react_reconciler}.

La principal fortaleza técnica de R3F radica en que delega la gestión del bucle de renderizado y la optimización de recursos al propio
reconciliador de React, garantizando que no exista sobrecarga de rendimiento (overhead) respecto al uso de Three.js vainilla,
al tiempo que facilita la integración de interactividad compleja en entornos web.

La selección de R3F se justifica por su capacidad para unificar la gestión de la interfaz de usuario 2D y la escena 3D bajo un único modelo
de programación, eliminando la necesidad de sincronizar manualmente el estado entre React y Three.js. Esta decisión arquitectónica
permite aprovechar las ventajas de ambas tecnologías sin comprometer el rendimiento, demostrando la viabilidad de paradigmas declarativos
en aplicaciones gráficas interactivas complejas.

\subsection{Algorítmos con \emph{Python 3}.\@ \emph{NumPy}}
La elección de Python 3 como lenguaje vehicular para los algoritmos de generación procedural no responde únicamente a su
sintaxis legible, sino a su consolidación como un entorno de producción robusto y versátil.
A diferencia de su concepción original como lenguaje de \emph{scripting}, las iteraciones modernas de Python 3 han introducido
características como las anotaciones de tipo y mejoras significativas en la gestión asíncrona, lo que ha permitido su adopción
masiva en infraestructuras críticas de ingeniería de software \cite{ramalho2022fluent}.
Su naturaleza multiparadigmática facilita la implementación de lógica compleja mediante patrones idiomáticos que reducen
la deuda técnica y favorecen la mantenibilidad del código a largo plazo. Además, su extensa biblioteca estándar y la madurez
de su ecosistema de terceros permiten desacoplar la lógica de generación matemática de la capa de presentación web,
asegurando una arquitectura modular donde los algoritmos pueden evolucionar independientemente del cliente gráfico.

No obstante, la naturaleza interpretada de Python puede suponer un cuello de botella en operaciones de cálculo intensivo.
Para mitigar esta limitación en el procesamiento de las matrices del laberinto, se ha integrado NumPy, la biblioteca
fundamental para la computación científica en este ecosistema \cite{mckinney2022python}. La ventaja crítica de NumPy
reside en su objeto principal, el \emph{ndarray}, que a diferencia de las listas nativas de Python —que son colecciones
de punteros a objetos dispersos en memoria—, almacena los datos en bloques de memoria contiguos, similar a
C \cite{harris2020array}. Esta arquitectura permite la ejecución de operaciones vectorizadas y \emph{broadcasting},
eliminando la necesidad de bucles explícitos en el nivel del intérprete y delegando el cómputo a rutinas optimizadas
de bajo nivel.

\subsection{WASM y ejectución de código nativo en navegadores web.\@ Pyodide.}
La necesidad de ejecutar operaciones computacionalmente costosas en el lado del cliente, superando las limitaciones
de rendimiento inherentes a JavaScript, motivó el surgimiento de \emph{WebAssembly} (WASM).
Concebido originalmente por el W3C, WASM se define como un formato de instrucciones binario diseñado para ser un objetivo
de compilación eficiente para lenguajes de alto nivel como C, C++ o Rust \cite{haas2017bringing}.
Su adopción en la actualidad responde a la capacidad de ejecutar código a velocidades cercanas a las nativas dentro
del entorno seguro (\emph{sandbox}) del navegador, permitiendo portar motores de física, decodificadores de video o
algoritmos científicos complejos que anteriormente requerían ejecución en servidor. Al tratarse de un estándar abierto
soportado por los principales motores de navegación, WASM actúa como una capa de abstracción sobre el hardware subyacente,
garantizando una ejecución determinista y eficiente independientemente de la plataforma del usuario \cite{rossberg2018bringing}.

En el contexto específico de este proyecto, para habilitar la ejecución del generador de laberintos escrito en Python
dentro del navegador, se ha integrado \emph{Pyodide}\footnote{\url{https://github.com/pyodide/pyodide}}. Esta solución no es un simple transpilador, sino una distribución
completa de CPython portada a WebAssembly mediante la cadena de herramientas \emph{Emscripten} \cite{pyodide_docs}.
Su arquitectura se distingue por incluir un sistema de archivos virtual (MEMFS) que simula el entorno de disco necesario
para la biblioteca estándar de Python y por su capacidad de cargar dinámicamente paquetes científicos compilados, como NumPy,
que mantienen sus optimizaciones en C/Fortran. Un aspecto crítico de su diseño es la interfaz de funciones foráneas (FFI)
bidireccional, que permite al código Python manipular el DOM y acceder a objetos JavaScript directamente, y viceversa,
facilitando una integración transparente entre ambos contextos.

\label{chap:estado}

% Descripción de las tecnologías que utilizas en tu trabajo. 
% Con dos o tres párrafos por cada tecnología, vale. 
% Se supone que aquí viene todo lo que no has hecho tú.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}
\label{sec:diseno}

El

\section{Arquitectura general}
\label{sec:arquitectura}
\subsection{ECS}
Para estructurar la lógica del juego, se ha optado por utilizar una adaptación del patrón de arquitectura
\emph{Entity-Component-System} (ECS). Este patrón permite separar claramente las responsabilidades
dentro del flujo de ejecución de la lógica del juego, facilitando la escalabilidad y el mantenimiento
del código.
Siguiendo esta idea, los elementos del juego se representan como \emph{entidades} compuestas por
\emph{componentes} que encapsulan datos específicos. Esto fuerza a los distintos elementos del estado
a ser estructurados de manera homogénea, facilitando la generalización de las operaciones sobre ellos.
Estas operaciones ocurren dentro de \emph{sistemas}, que procesan las entidades que poseen los
componentes relevantes para su función.

\section{Motor Lógico}
\label{sec:motor-logico}

El motor lógico constituye el núcleo ejecutivo de la aplicación, responsable de orquestar
el flujo temporal del juego mediante un bucle continuo que sincroniza la actualización del
estado interno con las capacidades de refresco del navegador. Su diseño se articula en torno
a un paradigma de solicitudes de fotograma (\emph{frame requests}) que delega al navegador
la gestión óptima del tiempo de renderizado, garantizando una experiencia fluida adaptada
al hardware del usuario. En cada iteración, el motor calcula el tiempo transcurrido desde
el fotograma anterior (\emph{delta time}), valor empleado para normalizar las velocidades
de movimiento y garantizar consistencia temporal independiente de la tasa de refresco.

El comportamiento del motor se rige por una máquina de estados finitos que controla las
transiciones entre las fases de la aplicación. Durante el estado de inicialización, el
motor permanece inactivo mientras se cargan los recursos necesarios y se genera el laberinto.
Una vez completada esta fase, transiciona al estado de ejecución activa, donde se procesa
la lógica de juego mediante un pipeline secuencial de sistemas especializados. Cuando se
cumplen las condiciones de finalización ---victoria o derrota---, el motor transiciona a
estados terminales que permiten reiniciar el ciclo o avanzar al siguiente nivel. Esta
arquitectura de estados garantiza la separación clara de responsabilidades y facilita la
gestión de transiciones complejas sin acoplamiento entre fases.

Las secciones siguientes detallan el proceso de inicialización del estado de juego,
describen los sistemas especializados que componen el pipeline de actualización y
especifican los criterios de finalización de partida.

\subsection{Generación}

Uno de los pilares fundamentales del proyecto es la generación procedural de laberintos.
La rejugabilidad, identificada como objetivo principal en la sección~\ref{sec:objetivos-especificos},
requiere que cada partida presente un escenario diferente, lo cual hace inviable el diseño manual
de niveles.
Se optó por implementar un sistema de generación procedural capaz de producir laberintos con las
características topológicas del clásico Pac-Man: un espacio cerrado con pasillos interconectados,
esquinas redondeadas y zonas de alta densidad de conexiones que favorecen tanto la huida como la
persecución.

Para este propósito, se llevó a cabo una reimplementación del algoritmo desarrollado por
Shaun Lebron~\cite{shaunlebron:pacman-mazegen-source}~\cite{shaunlebron:pacman-mazegen}.
La elección de este algoritmo se fundamenta en su capacidad demostrada para producir
laberintos que preservan la esencia del diseño original de Pac-Man, evitando tanto la
generación de espacios excesivamente abiertos como de corredores lineales predecibles.

El sistema genera representaciones de laberintos en forma de mapas de teselas o \emph{tilemaps}, es decir,
matrices bidimensionales donde cada elemento es un identificador del tipo de tesela que ocupa esa posición
(pared, pasillo, esquina, etc.).
Esta representación matricial facilita tanto el procesamiento algorítmico como la posterior
traducción a geometría tridimensional.
Para la implementación de este módulo, se seleccionó el lenguaje Python debido a la madurez
de su ecosistema en el manejo de estructuras de datos multidimensionales, específicamente a través
de la biblioteca NumPy.

A continuación, se detalla el flujo de generación del laberinto:

\subsubsection{Celdas}
Para poder comprender el funcionamiento del algoritmo, es necesario introducir el concepto de
\emph{celdas} (\emph{cells}).
Una celda es un nodo con propiedades utilizado para construir una versión abstracta del laberinto.
Los laberintos en Pac-Man se caracterizan por buscar deliberadamente la presencia de bucles. Por esto,
en términos de forma, es de mayor utilidad entenderlos nó como un conjunto de caminos interconectados,
sino como un puzzle formado por poliominós, figuras formadas por la unión de cuadrados. Cada celda representa
uno de estos cuadrados.


\subsubsection{La Matriz de Celdas y sus Conexiones}
Las celdas presentan una dualidad intrínseca: por un lado, son unidades discretas que componen la estructura de una
matriz bidimensional; por otro, actúan como nodos en un grafo que interconecta cada celda con sus vecinas ortogonalmente adyacentes
(vecindad de Von Newmann). Esto resulta muy útil, pues permite recorrer las celdas mediante la indexación matricial, pero también
permite acceder de una celda a otra, a partir de las conexiones que se establecen entre ellas.


El algoritmo comienza inicializando una matriz de celdas, donde cada celda está desconectada de sus vecinas. Resulta fundamental
precisar que todas las celdas contienen una referencia a sus adyacentes, independientemente de si pertenecen o no a la misma
figura poliominal. Por tanto, se define \emph{la celda siguiente en una dirección} como la celda colindante en dicha dirección
para una cierta celda. Esta es siempre es accesible desde la referencia que posee cada una de sus vecinas y solo se
considerarán conectadas las celdas que pertenezcan a la misma figura.

El algorítmo comienza creando las referencias entre las celdas adyacentes, manteniendo todas las conexiones inicialmente deshabilitadas.
En este punto, el algoritmo admite la presencia de conexiones predefinidas entre ciertas celdas, lo cual permite reservar zonas del
laberinto para funciones específicas, como la ``casa de los fantasmas''.

\subsubsection{Generación Mediante Figuras}
El núcleo del algoritmo radica en la generación iterativa de figuras poliominales que conectan las celdas adyacentes. En esta sección
se describe de forma detallada el proceso de generación.

El algoritmo itera las columnas de la matriz de celdas de izquierda a derecha. En cada columna, se seleccionan las celdas que aún no
pertenecen a ninguna figura. Estas celdas se denominan \emph{vacías}. Se selecciona una de estas celdas mediante una selección aleatoria de
distribución uniforme. A partir de esta celda, se comienza a construir una figura poliominal mediante la adición de celdas adyacentes.
La principal virtud del algoritmo es su riqueza a la hora de definir reglas de expansión de las figuras, manejando casos específicos y
definiendo un sistema de pesos que controla la probabilidad de expansión en función del tamaño actual de la figura. Tras agotar el
proceso de expansión, la figura resultante se consolida, marcando todas las celdas que la componen como ocupadas.

El algoritmo repite este proceso hasta que todas las celdas de la columna actual han sido ocupadas por alguna figura y, entonces,
avanza a la siguiente columna. El proceso continúa hasta que no quede ninguna celda vacía. Cabe detacar que es posible encontrar figuras
conectadas con los bordes superior, inferior o derecho de la matriz.

Dado que el laberinto debe ser simétrico respecto a un eje vertical, la matriz de celdas representa una mitad del laberinto, incluyendo
la columna central que actúa como eje de simetría. Se debe tener en cuenta que todas las figuras que contengan una celda en esta columna
resultarán en una única figura simétrica producto de la reflexión.


\subsubsection{Validación del Grafo Generado}
Tras el proceso de generación de figuras poliominales, se ejecuta una fase de validación que determina
si la configuración resultante cumple con los requisitos topológicos necesarios para producir un laberinto
funcional. Esta validación opera como filtro de calidad: las configuraciones que no superan los criterios
establecidos son descartadas, reiniciándose el proceso de generación hasta obtener una estructura válida.

La validación contempla dos categorías de restricciones estructurales fundamentales:

\paragraph{Cierre de esquinas.}
Las celdas situadas en las esquinas del borde derecho de la matriz no deben presentar conexiones hacia
el exterior del dominio. Esta restricción garantiza que el perímetro del laberinto permanezca cerrado y
que la posterior aplicación de la simetría axial no genere artefactos topológicos en los límites del
espacio de juego. La violación de esta condición resulta en el rechazo inmediato de la configuración.

\paragraph{Gestión de figuras cuadradas $2\times2$.}
El algoritmo identifica la presencia de configuraciones rectangulares de $2\times2$ celdas mediante
análisis de patrones de conectividad. Estas formaciones requieren tratamiento diferenciado según su
ubicación espacial:

\begin{itemize}
	\item \textbf{Rechazo en eje de simetría:} Las figuras $2\times2$ situadas en la columna central
	      de la matriz (eje de simetría del laberinto) son consideradas inválidas. Dado que la columna central
	      no se duplica durante la reflexión simétrica, estas configuraciones generarían espacios rectangulares
	      de $2\times3$ teselas completamente inaccesibles en el laberinto final, violando el principio de
	      navegabilidad total del espacio de juego.

	\item \textbf{Corrección fuera del eje:} Las figuras $2\times2$ localizadas en otras posiciones
	      son corregidas automáticamente mediante la apertura de conexiones internas entre sus cuatro celdas
	      constituyentes. Esta transformación convierte el rectángulo potencialmente problemático en una figura
	      plenamente conectada, eliminando el riesgo de generar huecos intransitables en la representación final
	      de teselas. Las celdas corregidas se unifican bajo un mismo grupo de pertenencia, consolidando su
	      tratamiento como una única entidad topológica.
\end{itemize}

Esta estrategia de validación y corrección selectiva maximiza el aprovechamiento de las configuraciones
generadas, requiriendo regeneración completa únicamente ante violaciones estructurales irrecuperables.
El proceso iterativo continúa hasta obtener un grafo que satisfaga simultáneamente ambas categorías de
restricciones, momento en el cual la generación prosigue hacia la fase de construcción de túneles.

\subsubsection{Generación de Túneles}
Los túneles laterales constituyen un elemento característico del diseño de \emph{Pac-Man}, proporcionando
rutas de escape estratégicas que conectan ambos extremos horizontales del laberinto. Su presencia es
fundamental para el equilibrio del juego, ya que permiten al jugador evadir situaciones de acorralamiento
al atravesar los límites laterales y reaparecer en el extremo opuesto.

La generación procedural de túneles se aborda mediante un sistema de clasificación jerárquica de candidatos,
evaluando las celdas del borde derecho de la matriz según criterios de idoneidad topológica. El proceso
distingue tres categorías de candidatos, ordenadas por preferencia:

\paragraph{Túneles de vacío (\emph{void tunnels}).}
Representan la configuración óptima para la creación de túneles. Se caracterizan por localizarse en
regiones donde la celda candidata y su vecina superior no pertenecen a ninguna figura poliominal, es
decir, se encuentran directamente conectadas al borde del laberinto. Esta disposición garantiza que el
túnel atraviese un espacio limpio, sin interferir con la estructura interna de figuras, produciendo
pasillos horizontales continuos que respetan la topología del resto del laberinto.

\paragraph{Callejones sin salida adyacentes (\emph{dead-end tunnels}).}
Constituyen una alternativa viable cuando no se dispone de suficientes candidatos de tipo vacío. Estos
túneles se sitúan junto a extremos de figuras que forman callejones sin salida en el borde del laberinto.
La construcción del túnel transforma el callejón en un pasillo transitable, integrándolo funcionalmente
en la red de navegación. Se distinguen dos subtipos: callejones simples, donde únicamente uno de los
vecinos verticales forma parte de una figura, y callejones dobles, donde tanto el vecino superior como
el inferior constituyen extremos de figuras distintas.

\paragraph{Túneles de borde genéricos (\emph{edge tunnels}).}
Se emplean como solución de última instancia cuando las categorías anteriores no proporcionan candidatos
suficientes. Estos túneles se establecen en posiciones intermedias del borde, sin consideraciones
específicas sobre la estructura adyacente, siempre que no interfieran con conexiones verticales que
pudieran fragmentar el túnel resultante.

El proceso de selección opera mediante un sistema de priorización: se evalúan primero los candidatos de
vacío, recurriendo a las categorías inferiores solo en caso de insuficiencia. La selección final se realiza
aleatoriamente dentro del conjunto de candidatos de la categoría más preferente disponible, garantizando
variabilidad entre generaciones.

Tras la selección del túnel, se ejecuta una fase de validación que verifica la ausencia de caminos verticales
que atraviesen el túnel proyectado. La existencia de tales interferencias invalidaría la configuración,
ya que generaría discontinuidades en el pasillo horizontal o colisiones con la geometría vertical del
laberinto. En caso de detección de incompatibilidades estructurales, se descarta la configuración completa
y se reinicia el proceso de generación del laberinto.

Finalmente, se aplica una fase de consolidación que elimina callejones sin salida residuales creados por
la inserción del túnel, conectándolos a las estructuras adyacentes para mantener la coherencia topológica
del grafo resultante. Este proceso asegura que el laberinto generado preserve la navegabilidad y las
propiedades de ciclos característicos del diseño original.


\subsubsection{El Laberinto de Teselas}
El grafo de celdas conectadas constituye una representación abstracta del laberinto, inadecuada para su
renderizado directo o para la lógica de navegación discreta del juego. Se requiere, por tanto, una
transformación que traduzca las relaciones topológicas entre celdas en una matriz de teselas
(\emph{tilemap}) donde cada elemento representa un tipo específico de componente del laberinto: pasillo
navegable, pared, punto consumible (\emph{pellet}) o potenciador (\emph{power pellet}).

\paragraph{Expansión y Simetrización.}
El proceso de conversión opera mediante una expansión espacial donde cada celda del grafo se proyecta
en una región de $3\times3$ teselas en la representación final. Esta expansión permite traducir las
conexiones entre celdas adyacentes en pasillos explícitos, mientras que las ausencias de conexión se
materializan como paredes. La matriz resultante representa únicamente la mitad derecha del laberinto,
incluyendo la columna central que actúa como eje de simetría. La mitad izquierda se genera mediante
reflexión especular, garantizando la simetría bilateral característica del diseño original de \emph{Pac-Man}.

\paragraph{Generación de Pasillos y Paredes.}
El algoritmo identifica las fronteras entre grupos de celdas distintos o las terminaciones de figuras
para establecer los pasillos navegables. Las teselas marcadas como camino (\texttt{'.'}) corresponden
a posiciones donde el jugador y los fantasmas pueden desplazarse. Tras definir la red de pasillos, se
ejecuta un proceso de relleno de paredes que marca como muros (\texttt{'|'}) todas las teselas vacías
adyacentes a pasillos, delimitando visualmente la geometría navegable del laberinto.

\paragraph{Integración de Túneles.}
Los túneles generados en la fase anterior se materializan en el \emph{tilemap} mediante la apertura de
pasillos en las posiciones extremas de las filas correspondientes. Previo a la generación de paredes,
se ejecuta un proceso de limpieza que elimina fragmentos de camino en los bordes que no constituyen
túneles válidos, evitando la aparición de callejones sin salida espurios en los límites del laberinto.
Esta operación recorre los caminos desde los bordes hacia el interior, eliminando segmentos lineales
hasta alcanzar intersecciones, consolidando así la topología deseada.

\paragraph{Colocación de Potenciadores.}
La distribución de \emph{power pellets} se realiza mediante un algoritmo de ubicación aleatoria
estratificada que divide el laberinto en mitades superior e inferior, garantizando una distribución
equilibrada de estos elementos críticos para la mecánica de juego. El proceso selecciona aleatoriamente
teselas de pasillo en cada mitad, marcándolas con el símbolo correspondiente (\texttt{'o'}). Esta
distribución espacial asegura que el jugador tenga acceso a potenciadores en distintas regiones del
laberinto, evitando concentraciones que desequilibren la dinámica de persecución.

\paragraph{Modificaciones Manuales.}
El sistema admite la aplicación de modificaciones manuales mediante funciones de callback que permiten
establecer teselas específicas en posiciones predeterminadas. Esta capacidad se emplea para definir
elementos estructurales fijos, como la ``cámara de los fantasmas'' (\emph{ghost house}), cuya geometría
requiere una configuración precisa no susceptible de generación procedural. Las modificaciones manuales
operan sobre el \emph{tilemap} expandido, respetando la simetría mediante el uso de funciones de escritura
simétricas.

El resultado final del proceso es una matriz bidimensional de caracteres donde cada símbolo representa
un tipo de tesela específico. Esta representación intermedia se convierte posteriormente en una matriz
numérica mediante un diccionario de traducción, facilitando su interpretación tanto por el motor gráfico
tridimensional como por los sistemas de navegación y colisión del juego.

\subsection{Inicialización del Estado de Juego}
\label{subsec:inicializacion-estado}

Previo a la ejecución del bucle principal, el motor ejecuta una fase de inicialización
que configura el estado inicial de todas las entidades participantes. Este proceso comienza
con la generación procedural del laberinto, operación delegada a un módulo externo implementado
en un entorno de ejecución optimizado para cálculo matricial. Dado que este algoritmo opera
en un contexto tecnológico divergente respecto al motor principal ---diseñado para aprovechar
bibliotecas de computación científica---, se emplea una capa de integración basada en
ejecución de código compilado en el navegador. Esta arquitectura permite ejecutar el
generador íntegramente en el cliente sin dependencias de servidor, recibiendo como resultado
una matriz numérica que codifica la topología del laberinto.

Una vez recibida esta matriz, el motor procede a su interpretación mediante iteración
sobre sus elementos, instanciando las entidades del sistema según el valor numérico de
cada celda. Las paredes se crean como entidades con componente de colisión que delimitan
el espacio navegable; los puntos consumibles y potenciadores se registran como entidades
recolectables en sus posiciones correspondientes; las zonas especiales ---como la cámara
de confinamiento de agentes--- se marcan con restricciones de acceso diferenciadas.

Paralelamente, se configuran las entidades dinámicas del juego. El jugador se posiciona
en el corredor central inferior con valores iniciales de salud, velocidad de movimiento
y dirección neutral. Los cuatro agentes autónomos se sitúan dentro de la cámara de
confinamiento con configuraciones diferenciadas: cada uno recibe un temporizador de salida
escalonado, una estrategia de persecución específica que define su personalidad y
parámetros de velocidad ajustados según el nivel de dificultad. Esta configuración
asimétrica garantiza que los agentes abandonen la cámara en momentos distintos, generando
patrones de presión progresiva sobre el jugador.

Al completarse la inicialización, el motor actualiza su estado interno y habilita el
bucle de ejecución, garantizando que todos los sistemas dispongan de las estructuras de
datos necesarias desde el primer fotograma.

\subsection{Sistemas de Actualización Lógica}
\label{subsec:sistemas-actualizacion}

Durante la fase de ejecución activa, el motor procesa secuencialmente un conjunto de
sistemas especializados que operan sobre las entidades del juego. Este pipeline responde
a un orden determinista que garantiza la coherencia lógica de las interacciones, donde
cada sistema asume que los anteriores han completado sus transformaciones sobre el estado
compartido.

\subsubsection{Sistema de Control del Jugador}

El sistema de control traduce los eventos de teclado en comandos de dirección para la
entidad del jugador. A diferencia de un mapeo directo, implementa una cola de direcciones
prioritarias que retiene las últimas intenciones del jugador incluso cuando el movimiento
en la dirección solicitada resulta temporalmente inválido. Esta estrategia minimiza la
latencia perceptual: si el jugador solicita un giro en una intersección antes de alcanzarla
físicamente, el sistema retiene la instrucción y la ejecuta en cuanto la nueva dirección
se torna viable. El buffer se actualiza cada fotograma, descartando direcciones obsoletas
y priorizando las más recientes, lo que permite al jugador encadenar movimientos complejos
con precisión temporal sin requerir sincronización perfecta entre entrada y posición.

\subsubsection{Sistema de Comportamiento de Agentes Autónomos}

El comportamiento de los agentes autónomos se rige por una máquina de estados que modela
sus fases operativas. Inicialmente permanecen confinados en su cámara durante un número
de iteraciones predefinido; al agotarse este contador, transicionan al estado de salida,
navegando hacia la apertura de la cámara mediante un objetivo fijo. Una vez fuera, alternan
cíclicamente entre dos modos principales: persecución activa y dispersión. Durante la
persecución, cada agente calcula un objetivo basado en su estrategia diferenciada; en
dispersión, se dirigen a esquinas predefinidas del laberinto, proporcionando respiros
tácticos al jugador. La duración de estos ciclos se configura según el nivel, reduciendo
progresivamente los periodos de dispersión para incrementar la dificultad.

Las estrategias de persecución definen la personalidad de cada agente. El agente rojo
persigue directamente la posición actual del jugador, actuando como amenaza inmediata.
El agente rosa calcula su objetivo proyectando cuatro teselas adelante en la dirección
de movimiento del jugador, ejecutando emboscadas predictivas en las intersecciones.
El agente cian implementa una estrategia cooperativa: calcula un vector desde la posición
del agente rojo hasta dos teselas adelante del jugador, duplica este vector y establece
el punto resultante como objetivo, generando flanqueos complejos que dependen de la
configuración espacial de ambos agentes. El agente naranja emplea un comportamiento dual
basado en la distancia euclidiana al jugador: si supera las ocho teselas, persigue
directamente; al acercarse, invierte su objetivo hacia su esquina de dispersión, simulando
desinterés.

La toma de decisiones de movimiento opera mediante evaluación de candidatos válidos. En
cada iteración donde el agente debe moverse, el sistema identifica las direcciones no
bloqueadas por paredes, descarta la dirección opuesta a su movimiento actual ---prohibiendo
reversiones que rompan el avance constante--- y calcula la distancia euclidiana desde cada
posición candidata hasta su objetivo actual. Selecciona la dirección que minimiza esta
distancia, actualizando el buffer de direcciones del agente. Este algoritmo determinista
permite a jugadores expertos predecir trayectorias y desarrollar estrategias de evasión
basadas en manipulación del posicionamiento relativo.

Cuando el jugador consume un potenciador, todos los agentes transicionan al estado de
vulnerabilidad, invirtiendo su relación depredador-presa. En este modo, los agentes
ignoran sus estrategias de persecución y adoptan movimiento pseudoaleatorio. Si son
alcanzados por el jugador, transicionan al estado de eliminación temporal, donde su
objetivo se fija en la cámara de confinamiento y su velocidad se incrementa para retornar
rápidamente. Al alcanzar la cámara, reinician su ciclo operativo tras un periodo de
confinamiento reducido.

\subsubsection{Sistema de Movimiento Discreto}

El sistema de movimiento traduce las intenciones direccionales de las entidades en
desplazamientos efectivos sobre el espacio discretizado del laberinto. Cada entidad
posee un temporizador de movimiento que acumula tiempo transcurrido; cuando este supera
un umbral configurado ---diferente para cada entidad---, se evalúa la viabilidad del
movimiento en la dirección prioritaria de su buffer. El sistema consulta la topología
del laberinto para verificar que la tesela destino no constituya una pared ni, en el
caso del jugador, una zona de acceso restringido. Si la validación resulta exitosa,
actualiza la posición de la entidad y reinicia su temporizador; en caso contrario,
evalúa la siguiente dirección del buffer hasta agotar opciones.

La gestión de túneles laterales se implementa mediante detección de coordenadas extremas.
Cuando una entidad intenta desplazarse más allá del límite horizontal del laberinto,
el sistema sustituye la posición destino por la coordenada simétrica en el extremo
opuesto, materializando la teleportación característica de estos pasillos especiales.
Esta solución mantiene la continuidad percibida del espacio sin requerir geometría
adicional ni casos especiales en los sistemas de navegación.

\subsubsection{Sistema de Detección de Colisiones}

El sistema de colisiones evalúa la coincidencia espacial entre el jugador y los agentes
autónomos. Dado que el movimiento opera sobre un espacio discreto, la detección se
reduce a comparación exacta de coordenadas. El sistema se ejecuta únicamente cuando
al menos una entidad ha completado un movimiento en el fotograma actual, evitando
evaluaciones redundantes.

Al detectar coincidencia, el efecto varía según el estado del agente. Si opera en modo
normal o dispersión, el jugador recibe daño, su contador de salud decrementa y se
activa un periodo de invulnerabilidad temporal medido en iteraciones, durante el cual
se suprimen evaluaciones adicionales de colisión. Si el agente se encuentra en estado
vulnerable, la colisión resulta en su eliminación temporal, transicionando forzadamente
al modo de retorno a la cámara. Los agentes en tránsito de retorno no generan colisiones,
permitiendo al jugador atravesarlos sin consecuencias.

\subsubsection{Sistema de Recolección de Objetos}

El sistema de recolección opera consultando el estado del laberinto en la posición
actual de entidades con capacidad de recolectar. Cuando el jugador ocupa una tesela
que contiene un objeto consumible, el sistema identifica su tipo y ejecuta los efectos
correspondientes. Los puntos comunes incrementan la puntuación y se eliminan del registro
del laberinto; los potenciadores incrementan sustancialmente la puntuación, se eliminan
del registro y desencadenan un evento global que fuerza la transición de todos los
agentes al estado vulnerable durante un número fijo de iteraciones. El sistema actualiza
contadores globales empleados posteriormente para evaluar las condiciones de victoria.

\subsection{Condiciones de Finalización}
\label{subsec:condiciones-finalizacion}

El motor evalúa en cada iteración dos criterios terminales. El criterio de victoria
se satisface cuando el contador de objetos consumibles recolectados alcanza el total
inicialmente registrado durante la fase de interpretación del laberinto, indicando que
el jugador ha limpiado completamente el nivel. El criterio de derrota se activa cuando
el contador de salud del jugador alcanza cero tras acumular suficientes colisiones con
agentes. Al detectar cualquiera de estas condiciones, el motor detiene el procesamiento
de sistemas de actualización y transiciona hacia estados terminales que gestionan la
presentación de resultados y permiten al usuario reiniciar el ciclo o avanzar al
siguiente nivel generado proceduralmente.


\section{Sistema Gráfico}
El sistema gráfico se estructura en tres capas diferenciadas: una interfaz de usuario
bidimensional basada en componentes reutilizables, un subsistema de visualización
de datos del juego superpuesto a la escena tridimensional, y la propia escena que
renderiza la geometría del laberinto y las entidades mediante técnicas de gráficos
por computador. Esta segregación favorece la separación de responsabilidades entre
presentación, visualización de estado y representación espacial.

\subsection{Interfaz de Usuario}
La arquitectura de componentes de interfaz se organiza en una jerarquía de cuatro
niveles inspirada en la metodología de diseño atómico y los principios SOLID. El primer
nivel comprende componentes atómicos sin dependencias internas (botones, entradas de
texto, iconos), que no acceden al estado global y operan exclusivamente mediante
propiedades. El segundo nivel agrupa componentes compuestos que combinan entre uno y tres
componentes atómicos para encapsular patrones reutilizables (modales, grupos de botones,
visualizadores de estadísticas). El tercer nivel contiene componentes de distribución
espacial que integran múltiples almacenes de estado y organizan secciones completas de
la interfaz. El cuarto nivel orquesta vistas completas de aplicación que coordinan todos
los niveles inferiores. Esta jerarquía impone un flujo de dependencias unidireccional
estricto: los niveles superiores pueden importar componentes de niveles inferiores, pero
la relación inversa está prohibida, garantizando modularidad y facilitando el
mantenimiento mediante responsabilidad única por componente.

\subsection{Head-Up Display}
El sistema de visualización superpuesta actúa como puente entre la escena
tridimensional y la interfaz bidimensional, leyendo datos de múltiples almacenes de
estado (estado general del juego, entidad del jugador, información del laberinto) para
presentar métricas en tiempo real sin interferir con el área de renderizado
tridimensional. Este subsistema emplea actualización reactiva: los componentes se
suscriben a cambios específicos en el estado y se re-renderizan únicamente cuando las
propiedades observadas mutan, minimizando el coste computacional de actualización. La
capa también gestiona eventos de teclado para pausar la simulación o invocar menús
contextuales, coordinando la transición entre estados de juego mediante el almacén
centralizado de estado general. La distribución espacial sigue un esquema de anclaje
absoluto en las esquinas del viewport, reservando el área central exclusivamente para la
escena tridimensional.

\subsection{Escena}
La escena tridimensional se construye mediante un paradigma declarativo de grafo de
escena, donde cada nodo representa una entidad geométrica (mallas poligonales de
personajes, geometría procedimental del laberinto) o un elemento de iluminación. Las
mallas de entidades se suscriben al estado lógico discreto (posiciones en celdas,
direcciones de movimiento, temporizadores de desplazamiento) y aplican una técnica de
interpolación posicional que transforma las coordenadas discretas del espacio lógico en
trayectorias continuas del espacio de renderizado. Esta interpolación se calcula en cada
fotograma mediante una función lineal ponderada por el ratio entre tiempo transcurrido y
duración total del movimiento entre celdas adyacentes, generando animaciones fluidas a
pesar de que el motor lógico opere con actualizaciones discretas a intervalos variables.
El desacoplamiento entre la frecuencia de actualización lógica (típicamente 10--15 Hz) y
la frecuencia de renderizado (60 Hz o superior) permite mantener fluidez visual sin
incrementar la carga computacional del motor de simulación. La configuración de la cámara
emplea proyección perspectiva con rotación fija en ángulo cenital oblicuo, estableciendo
una vista isométrica aproximada que recuerda a la estética del género roguelike
tridimensional, mientras que el sistema de iluminación combina luz ambiental uniforme con
fuentes puntuales para generar contraste volumétrico.
\section{Estado}

\section{Prototipos y Metodología}
% TODO - Citar Scrum 
A fin de organizar mejor el proceso de desarrollo del proyecto, se ha requerido un sistema que permita planificar el trabajo de forma efectiva y sostenible en el medio plazo.
Pese a que el proyecto ha sido desarrollado en su totalidad por el alumno, con la ayuda y supervisión del tutor, la metodología de trabajo se ha asemejado a la propuesta en [[Scrum]]. Se han definido distintos sprints, asociados a una serie de objetivos.
Cada uno de estos sprints debe resultar en una versión estable del juego. Las ideas que pudieran surgir durante el transcurso de un sprint han sido apuntadas y revisadas al finalizar cada uno de los mismos.
% TODO - Expandir
Todos los elementos de la arquitectura se relacionan mediante el estado.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXPERIMENTOS Y VALIDACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Experimentos y validación}
\label{chap:experimentos}

Este capítulo se introdujo como requisito en 2019.
Describe los experimentos y casos de test que tuviste que implementar para validar tus resultados.
Incluye también los resultados de validación que permiten afirmar que tus resultados son correctos.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}
\label{chap:resultados}

En este capítulo se incluyen los resultados de tu trabajo fin de grado.

Si es una herramienta de análisis lo que has realizado, aquí puedes poner ejemplos de haberla utilizado para que se vea su utilidad.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

Esta sección es la sección espejo de las dos primeras del capítulo de objetivos, donde se planteaba el objetivo general y se elaboraban los específicos.

Es aquí donde hay que debatir qué se ha conseguido y qué no.
Cuando algo no se ha conseguido, se ha de justificar, en términos de qué problemas se han encontrado y qué medidas se han tomado para mitigar esos problemas.

Y si has llegado hasta aquí, siempre es bueno pasarle el corrector ortográfico, que las erratas quedan fatal en la memoria final.
Para eso, en Linux tenemos aspell, que se ejecuta de la siguiente manera desde la línea de \emph{shell}:

\begin{verbatim}
  aspell --lang=es_ES -c memoria.tex
\end{verbatim}

\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

Aquí viene lo que has aprendido durante el Grado/Máster y que has aplicado en el TFG/TFM.
Una buena idea es poner las asignaturas más relacionadas y comentar en un párrafo los conocimientos y habilidades puestos en práctica.

\begin{enumerate}
	\item a
	\item b
\end{enumerate}


\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

Aquí viene lo que has aprendido en el Trabajo Fin de Grado/Máster.

\begin{enumerate}
	\item Aquí viene uno.
	\item Aquí viene otro.
\end{enumerate}


\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Ningún proyecto ni software se termina, así que aquí vienen ideas y funcionalidades que estaría bien tener implementadas en el futuro.

Es un apartado que sirve para dar ideas de cara a futuros TFGs/TFMs.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Manual de usuario}
\label{app:manual}

Esto es un apéndice.
Si has creado una aplicación, siempre viene bien tener un manual de usuario.
Pues ponlo aquí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
